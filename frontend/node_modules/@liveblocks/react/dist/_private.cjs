"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }


























var _chunkIQBSX6NScjs = require('./chunk-IQBSX6NS.cjs');

// src/lib/use-layout-effect.ts
var _react = require('react');
var useLayoutEffect = typeof window !== "undefined" ? _react.useLayoutEffect : _react.useEffect;

// src/use-group.ts



var _core = require('@liveblocks/core');

function selectorFor_useGroup(state) {
  if (state === void 0 || _optionalChain([state, 'optionalAccess', _ => _.isLoading])) {
    return _nullishCoalesce(state, () => ( { isLoading: true }));
  }
  if (state.error) {
    return state;
  }
  return {
    isLoading: false,
    group: state.data
  };
}
function useGroup(groupId) {
  const client = _chunkIQBSX6NScjs.useClient.call(void 0, );
  const store = client[_core.kInternal].httpClient.groupsStore;
  const getGroupState = _react.useCallback.call(void 0, 
    () => store.getItemState(groupId),
    [store, groupId]
  );
  _react.useEffect.call(void 0, () => {
    void store.enqueue(groupId);
  }, [store, groupId]);
  return _chunkIQBSX6NScjs.useSyncExternalStoreWithSelector.call(void 0, 
    store.subscribe,
    getGroupState,
    getGroupState,
    selectorFor_useGroup,
    _core.shallow
  );
}

// src/use-mention-suggestions.ts


var MENTION_SUGGESTIONS_DEBOUNCE = 500;
function normalizeMentionSuggestions(suggestions) {
  return suggestions.map(
    (suggestion) => typeof suggestion === "string" ? { kind: "user", id: suggestion } : suggestion
  );
}
function useMentionSuggestions(roomId, search) {
  const [mentionSuggestions, setMentionSuggestions] = _react.useState.call(void 0, );
  const lastInvokedAt = _react.useRef.call(void 0, );
  const resolveMentionSuggestions = _chunkIQBSX6NScjs.useResolveMentionSuggestions.call(void 0, );
  const mentionSuggestionsCache = _chunkIQBSX6NScjs.useMentionSuggestionsCache.call(void 0, );
  _react.useEffect.call(void 0, () => {
    if (search === void 0 || !resolveMentionSuggestions) {
      return;
    }
    const resolveMentionSuggestionsArgs = { text: search, roomId };
    const mentionSuggestionsCacheKey = _core.stableStringify.call(void 0, 
      resolveMentionSuggestionsArgs
    );
    let debounceTimeout;
    let isCanceled = false;
    const getMentionSuggestions = async () => {
      try {
        lastInvokedAt.current = performance.now();
        const rawMentionSuggestions = await resolveMentionSuggestions(
          resolveMentionSuggestionsArgs
        );
        if (!isCanceled) {
          const normalizedSuggestions = normalizeMentionSuggestions(
            rawMentionSuggestions
          );
          setMentionSuggestions(normalizedSuggestions);
          mentionSuggestionsCache.set(
            mentionSuggestionsCacheKey,
            normalizedSuggestions
          );
        }
      } catch (error) {
        console.error(_optionalChain([error, 'optionalAccess', _2 => _2.message]));
      }
    };
    if (mentionSuggestionsCache.has(mentionSuggestionsCacheKey)) {
      const cachedSuggestions = mentionSuggestionsCache.get(
        mentionSuggestionsCacheKey
      );
      setMentionSuggestions(cachedSuggestions);
    } else if (!lastInvokedAt.current || Math.abs(performance.now() - lastInvokedAt.current) > MENTION_SUGGESTIONS_DEBOUNCE) {
      void getMentionSuggestions();
    } else {
      debounceTimeout = window.setTimeout(() => {
        void getMentionSuggestions();
      }, MENTION_SUGGESTIONS_DEBOUNCE);
    }
    return () => {
      isCanceled = true;
      window.clearTimeout(debounceTimeout);
    };
  }, [search, roomId, resolveMentionSuggestions, mentionSuggestionsCache]);
  return mentionSuggestions;
}

// src/use-sync-source.ts


function useSyncSource() {
  const client = _chunkIQBSX6NScjs.useClient.call(void 0, );
  const createSyncSource = client[_core.kInternal].createSyncSource;
  const [syncSource, setSyncSource] = _react.useState.call(void 0, );
  _react.useEffect.call(void 0, () => {
    const newSyncSource = createSyncSource();
    setSyncSource(newSyncSource);
    return () => newSyncSource.destroy();
  }, [createSyncSource]);
  return syncSource;
}






























exports.getUmbrellaStoreForClient = _chunkIQBSX6NScjs.getUmbrellaStoreForClient; exports.useAddRoomCommentReaction = _chunkIQBSX6NScjs.useAddRoomCommentReaction; exports.useClientOrNull = _chunkIQBSX6NScjs.useClientOrNull; exports.useCreateRoomComment = _chunkIQBSX6NScjs.useCreateRoomComment; exports.useCreateRoomThread = _chunkIQBSX6NScjs.useCreateRoomThread; exports.useCreateTextMention = _chunkIQBSX6NScjs.useCreateTextMention; exports.useDeleteRoomComment = _chunkIQBSX6NScjs.useDeleteRoomComment; exports.useDeleteRoomThread = _chunkIQBSX6NScjs.useDeleteRoomThread; exports.useDeleteTextMention = _chunkIQBSX6NScjs.useDeleteTextMention; exports.useEditRoomComment = _chunkIQBSX6NScjs.useEditRoomComment; exports.useEditRoomThreadMetadata = _chunkIQBSX6NScjs.useEditRoomThreadMetadata; exports.useGroup = useGroup; exports.useLatest = _chunkIQBSX6NScjs.useLatest; exports.useLayoutEffect = useLayoutEffect; exports.useMarkRoomThreadAsRead = _chunkIQBSX6NScjs.useMarkRoomThreadAsRead; exports.useMarkRoomThreadAsResolved = _chunkIQBSX6NScjs.useMarkRoomThreadAsResolved; exports.useMarkRoomThreadAsUnresolved = _chunkIQBSX6NScjs.useMarkRoomThreadAsUnresolved; exports.useMentionSuggestions = useMentionSuggestions; exports.useMentionSuggestionsCache = _chunkIQBSX6NScjs.useMentionSuggestionsCache; exports.useRemoveRoomCommentReaction = _chunkIQBSX6NScjs.useRemoveRoomCommentReaction; exports.useReportTextEditor = _chunkIQBSX6NScjs.useReportTextEditor; exports.useResolveMentionSuggestions = _chunkIQBSX6NScjs.useResolveMentionSuggestions; exports.useRoomAttachmentUrl = _chunkIQBSX6NScjs.useRoomAttachmentUrl; exports.useRoomPermissions = _chunkIQBSX6NScjs.useRoomPermissions; exports.useRoomThreadSubscription = _chunkIQBSX6NScjs.useRoomThreadSubscription; exports.useSignal = _chunkIQBSX6NScjs.useSignal; exports.useSyncExternalStoreWithSelector = _chunkIQBSX6NScjs.useSyncExternalStoreWithSelector; exports.useSyncSource = useSyncSource; exports.useYjsProvider = _chunkIQBSX6NScjs.useYjsProvider;
//# sourceMappingURL=_private.cjs.map